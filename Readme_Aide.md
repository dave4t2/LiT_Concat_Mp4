# üìò Documentation : `LiT_Concat_Video_Perso_Planque.py`

## 1. Introduction

### üéØ **Objectif**

Ce script automatise la **concat√©nation de trois segments vid√©o MP4** en un seul fichier :

* `video1.mp4` ‚Äì une introduction de 5 minutes, toujours identique.
* Une **vid√©o personnalis√©e** `video2.mp4` (~20 secondes), unique pour chaque fichier.
* `video3.mp4` ‚Äì une courte conclusion de 20 secondes, bas√©e sur le m√™me clip de base avec de petites modifications visuelles par personne.

Il est con√ßu pour **traiter efficacement des milliers de trios** avec :

* Pas de r√©-encodage (pr√©servation de la qualit√© originale).
* Performance rapide gr√¢ce √† FFmpeg et au format `.ts`.
* Journalisation pour la tra√ßabilit√©.

---

### ‚öôÔ∏è **Comment √ßa fonctionne (Vue d'ensemble)**

1. V√©rifie la pr√©sence des r√©pertoires et des composants vid√©o attendus.
2. Chaque fichier MP4 est **converti au format MPEG-TS**, qui est adapt√© au streaming et s√ªr pour la concat√©nation.
3. Les fichiers `.ts` r√©sultants sont list√©s dans un fichier temporaire et **concat√©n√©s √† l'aide de FFmpeg**.
4. Le fichier final `.mp4` est enregistr√© dans le r√©pertoire de sortie.
5. Les fichiers temporaires sont supprim√©s.

---

## 2. Exigences pour les fichiers d'entr√©e

Pour que le script fonctionne de mani√®re fiable sans r√©-encodage, **les vid√©os d'entr√©e doivent respecter des contraintes d'encodage strictes**.

### ‚úÖ **Contraintes d'encodage obligatoires**

Les 3 vid√©os d'entr√©e doivent :

* √ätre encod√©es avec :

  * **Codec vid√©o** : `H.264 / AVC` (souvent affich√© comme `avc1`)
  * **Codec audio** : `AAC`
* Avoir la **m√™me r√©solution** : `720x1260` (portrait).
* Avoir le **m√™me taux de trame** : `24 fps`.
* Avoir des **structures GOP compatibles**, id√©alement :

  * Commencer et se terminer par des **I-frames** pour une concat√©nation s√ªre.
  * √âviter les **B-frames √† la fin** des clips.

---

### üîç **Comment v√©rifier l'encodage (avec `ffprobe`)**

Pour inspecter l'encodage d'un fichier vid√©o, ex√©cutez :

```bash
ffprobe -v error -select_streams v:0 -show_entries stream=codec_name,codec_type,width,height,avg_frame_rate -of default=noprint_wrappers=1 input.mp4
```

Pour v√©rifier le codec audio :

```bash
ffprobe -v error -select_streams a:0 -show_entries stream=codec_name,codec_type -of default=noprint_wrappers=1 input.mp4
```

**Exemple de sortie attendue :**

```
codec_name=h264
codec_type=video
width=720
height=1260
avg_frame_rate=24/1
---
codec_name=aac
codec_type=audio
```

Vous pouvez √©galement obtenir un aper√ßu complet en utilisant :

```bash
ffprobe -hide_banner -i input.mp4
```

Recherchez :

* `Stream #0:0` ‚Üí vid√©o : h264 (Main)
* `Stream #0:1` ‚Üí audio : aac

---

### ‚ùå Que se passe-t-il si les contraintes ne sont pas respect√©es ?

Si les codecs, la r√©solution ou le taux de trame ne correspondent pas :

* FFmpeg peut **√©chouer silencieusement** ou **produire une sortie corrompue**.
* Les fichiers concat√©n√©s peuvent pr√©senter des **artefacts**, des **images saut√©es** ou un **d√©calage audio**.

Pour corriger cela :

* Utilisez FFmpeg pour r√©-encoder avec des param√®tres align√©s (nous pouvons fournir une commande si n√©cessaire).

---

## 3. Workflow √©tape par √©tape

### üß© √âtape 1 : **Configuration et initialisation**

#### üõ† Imports et journalisation

```python
import os, subprocess, logging
from datetime import datetime
```

* Les biblioth√®ques standard sont utilis√©es (aucune d√©pendance tierce).
* Un fichier journal horodat√© est cr√©√© dans le r√©pertoire `./logs/`.

```python
log_filename = f"./logs/concat_Launch_v2_{datetime.now().strftime('%Y_%m_%d_%H_%M_%S')}_Log.txt"
logging.basicConfig(...)
```

üìå **Pourquoi ?**

* Pour le d√©bogage et les audits.
* Utile lors du traitement de grands lots pour identifier les fichiers √©chou√©s ou ignor√©s.

---

### üìÅ √âtape 2 : **D√©finir les chemins et valider la pr√©sence des fichiers**

```python
video1_path = './input/Video1/video1.mp4'
video2_path = './input/Video2/'
video3_path = './input/Video3/video3.mp4'
ConcatVideo_path = './output'
temp_folder = './temp'
```

* `video1` et `video3` sont r√©utilis√©s pour chaque trio.
* Le r√©pertoire `video2` contient les clips personnalis√©s.

```python
if not os.path.exists(...) ...
```

üß™ **Pourquoi ?**

* Emp√™che le script de planter en cours d'ex√©cution √† cause de chemins d'entr√©e ou de sortie manquants.
* Assure un √©chec pr√©coce avec des journaux clairs.

---

### üîÅ √âtape 3 : **Boucler sur les MP4 personnalis√©s**

```python
video_files = os.listdir(video2_path)
mp4_files = [file for file in video_files if file.endswith(".mp4")]
```

* R√©cup√®re tous les fichiers MP4 personnalis√©s.
* Pour chacun, cr√©e un fichier concat√©n√© en sortie.

```python
if os.path.exists(output_path):
    continue
```

üìå **Pourquoi ?**

* √âvite le traitement redondant des vid√©os d√©j√† g√©n√©r√©es.

---

### üîÑ √âtape 4 : **Convertir les MP4 au format TS**

```python
def convert_to_ts(input_file, output_file):
    run_ffmpeg_command([
        "ffmpeg", "-i", input_file, "-c", "copy",
        "-bsf:v", "h264_mp4toannexb", "-f", "mpegts", output_file, "-y"
    ])
```

üì¶ **Objectif de cette √©tape** :

* Convertit chaque MP4 en fichier `.ts` (MPEG-TS) sans r√©-encodage.
* Ajoute les en-t√™tes Annex B n√©cessaires (`h264_mp4toannexb`) pour rendre les flux H.264 **s√ªrs pour la concat√©nation**.

üí° **Pourquoi TS ?**

* TS permet une concat√©nation bas√©e sur les flux avec moins de probl√®mes de lecture.
* La structure MP4 (atomes moov, index) n'est pas naturellement adapt√©e √† la concat√©nation.

---

### üìù √âtape 5 : **Cr√©er une liste d'entr√©e FFmpeg pour la concat√©nation**

```python
with open(input_list_file, "w") as f:
    f.write(f"file '{ts1_path}'\n")
    f.write(f"file '{ts2_path}'\n")
    f.write(f"file '{ts3_path}'\n")
```

üìå **Pourquoi ?**

* FFmpeg attend un fichier texte avec les chemins d'entr√©e lors de l'utilisation de `-f concat`.
* Les chemins absolus sont utilis√©s pour √©viter les probl√®mes de r√©solution de chemins relatifs.

---

### üé¨ √âtape 6 : **Concat√©ner avec FFmpeg**

```python
run_ffmpeg_command([
    "ffmpeg", "-f", "concat", "-safe", "0", "-fflags", "+genpts",
    "-i", input_list_file, "-c", "copy", "-bsf:a", "aac_adtstoasc",
    "-y", output_path
])
```

üîç **Explication** :

* `-f concat` : Indique √† FFmpeg de lire une liste de fichiers d'entr√©e.
* `-safe 0` : Autorise les chemins de fichiers non s√©curis√©s (comme les chemins absolus).
* `-fflags +genpts` : R√©g√©n√®re les horodatages pour une lecture plus fluide.
* `-c copy` : Pas de r√©-encodage ; rapide et sans perte.
* `-bsf:a aac_adtstoasc` : Corrige le flux AAC pour le conteneur MP4.

üìå **Pourquoi cette s√©quence exacte ?**

* Cette combinaison garantit vitesse, compatibilit√© et lecture propre.

---

### üßπ √âtape 7 : **Nettoyer les fichiers temporaires**

```python
os.remove(ts1_path)
os.remove(ts2_path)
os.remove(ts3_path)
os.remove(input_list_file)
```

üìå **Pourquoi ?**

* Garde le r√©pertoire `./temp` propre.
* √âvite l'encombrement et les conflits futurs de lecture/√©criture.

---

## ‚úÖ 4. R√©sum√© des pr√©-requis

| Exigence                      | Pourquoi c'est important                                |
| ----------------------------- | ------------------------------------------------------ |
| FFmpeg install√©               | Toutes les op√©rations vid√©o en d√©pendent.             |
| Format vid√©o d'entr√©e : H.264/AAC | N√©cessaire pour la compatibilit√© des fichiers `.ts`. |
| R√©solution et fps identiques  | √âvite les d√©calages audio/vid√©o ou les erreurs de lecture. |
| Pas de B-frames √† la fin des segments | R√©duit les artefacts de d√©codage apr√®s concat√©nation. |
| Python 3.x                    | Ex√©cute le script et g√®re les entr√©es/sorties et les journaux. |
| Structure des r√©pertoires     | Les dossiers d'entr√©e/sortie attendus doivent exister au pr√©alable. |

---

## 5. Installation de FFmpeg

FFmpeg est une d√©pendance essentielle pour le traitement vid√©o. Suivez ces √©tapes pour l'installer :

1. **T√©l√©charger FFmpeg** :
   - Rendez-vous sur le [site officiel de FFmpeg](https://ffmpeg.org/download.html).
   - Choisissez la version appropri√©e pour votre syst√®me d'exploitation (Windows, macOS ou Linux).

2. **Installer FFmpeg** :
   - Extrayez l'archive t√©l√©charg√©e dans un r√©pertoire de votre choix (par exemple, `C:\ffmpeg` sur Windows).
   - Ajoutez le dossier `bin` du r√©pertoire extrait √† votre PATH syst√®me :
     - Sur Windows :
       1. Ouvrez "Variables d'environnement" dans les Propri√©t√©s syst√®me.
       2. Ajoutez le chemin vers le dossier `bin` (par exemple, `C:\ffmpeg\bin`) √† la variable `Path`.
     - Sur macOS/Linux :
       ```bash
       export PATH=$PATH:/chemin/vers/ffmpeg/bin
       ```

3. **V√©rifier l'installation** :
   - Ouvrez un terminal ou une invite de commande et ex√©cutez :
     ```bash
     ffmpeg -version
     ```
   - Vous devriez voir les d√©tails de la version de FFmpeg.

---

## 9. Installer ffprobe

`ffprobe` est un outil inclus avec FFmpeg pour inspecter les fichiers vid√©o et audio. Il est install√© en m√™me temps que FFmpeg.

1. **V√©rifier l'installation de ffprobe** :
   - Apr√®s avoir install√© FFmpeg, v√©rifiez si `ffprobe` est disponible en ex√©cutant :
     ```bash
     ffprobe -version
     ```
   - Vous devriez voir les d√©tails de la version de `ffprobe`.

2. **Utilisation** :
   - Utilisez `ffprobe` pour inspecter les propri√©t√©s des fichiers vid√©o et audio, comme d√©crit dans la section "Comment v√©rifier l'encodage" de ce document.

---

## ‚ö†Ô∏è 6. Limitations connues et cas particuliers

### ‚ùó 1. **Incompatibilit√© des entr√©es**

Si une vid√©o d'entr√©e ne respecte **pas** les contraintes d'encodage (par exemple, r√©solution non correspondante, mauvais codec), FFmpeg :

* Peut √©chouer directement avec une erreur, ou
* Produire une sortie inutilisable ou d√©fectueuse.

üìå **Recommandation** : Validez toujours les entr√©es avec `ffprobe`.

---

### ‚ùó 2. **Probl√®mes de frames cach√©es (par exemple, B-frames aux limites des segments)**

* Si un clip se termine par une **B-frame** ou ne commence pas par une **I-frame**, des artefacts de lecture peuvent appara√Ætre apr√®s concat√©nation.
* √âtant donn√© que le script ne fait **pas de r√©-encodage**, il ne peut pas corriger cela √† l'ex√©cution.

üìå **Recommandation** : Assurez des structures GOP propres lors de la pr√©paration des vid√©os.

---

### ‚ùó 3. **Pas de parall√©lisation**

* Le script traite actuellement un fichier √† la fois, ce qui peut √™tre lent pour des milliers de fichiers.

üìå **Solution de contournement** : Vous pouvez ex√©cuter manuellement le script dans plusieurs terminaux sur diff√©rents sous-ensembles de vid√©os ‚Äî ou des am√©liorations futures peuvent introduire la multiprocessus.

---

### ‚ùó 4. **Gestion des erreurs centralis√©e**

* Une erreur arr√™te tout le script (par exemple, si FFmpeg plante sur une mauvaise entr√©e).
* Les journaux sont disponibles pour le d√©bogage, mais le lot continue uniquement si vous le red√©marrez.

üìå **Recommandation** : Ajoutez des blocs try/except par it√©ration si vous souhaitez continuer malgr√© les √©checs.

---

## üß™ 7. Conseils de d√©bogage et contr√¥le qualit√©

### üßæ V√©rifiez les informations de la vid√©o de sortie

Pour inspecter l'encodage du fichier de sortie :

```bash
ffprobe -i ./output/bodycam_example.mp4
```

Assurez-vous :

* `codec_name=h264` pour la vid√©o
* `codec_name=aac` pour l'audio
* `avg_frame_rate=24/1`
* Pas de frames perdues ou d'avertissements

---

### üîç Visualisez les fichiers TS interm√©diaires

Si vous suspectez qu'un segment `.ts` est mal form√© :

```bash
ffplay ./temp/intermediate_2.ts
```

Cela vous permet de d√©boguer si l'erreur provient du clip personnalis√© ou de la logique de concat√©nation.

---

### ü™µ Lisez le journal

Chaque ex√©cution du script g√©n√®re un journal comme :

```
./logs/concat_Launch_v2_2025_05_09_14_35_12_Log.txt
```

Recherchez :

* `[INFO] Processing completed successfully`
* `[ERROR] FFmpeg command failed` avec une sortie stderr d√©taill√©e

---

### üõ† Correction des mauvaises entr√©es

Pour r√©-encoder une vid√©o d'entr√©e d√©fectueuse et forcer une structure correcte :

```bash
ffmpeg -i bad_input.mp4 -c:v libx264 -preset fast -crf 18 -g 24 -c:a aac -b:a 128k fixed_input.mp4
```

Cela garantit :

* H.264 + AAC
* Images cl√©s toutes les secondes (`-g 24`)
* Flux audio compatible

---

## üöÄ 8. Am√©liorations futures

### üßµ 1. Support de la multiprocessus

Utilisez `multiprocessing.Pool` de Python pour ex√©cuter des lots en parall√®le, particuli√®rement utile avec un stockage SSD et plusieurs c≈ìurs.

### üß™ 2. Validateur d'entr√©e

Ajoutez un script ou un drapeau qui :

* Ex√©cute `ffprobe` sur toutes les entr√©es
* Confirme la r√©solution, le taux de trame et les codecs avant la concat√©nation

---

## üìé 9. Annexe : Aide-m√©moire CLI

| T√¢che                          | Exemple de commande                                                   |
| ------------------------------ | ---------------------------------------------------------------------- |
| Inspecter l'encodage vid√©o     | `ffprobe -hide_banner -i input.mp4`                                    |
| Lire un fichier .ts interm√©diaire | `ffplay ./temp/intermediate_2.ts`                                      |
| Concat√©ner manuellement des fichiers .ts | `ffmpeg -f concat -i input_list.txt -c copy output.mp4`                |
| R√©-encoder pour compatibilit√©  | `ffmpeg -i input.mp4 -c:v libx264 -g 24 -c:a aac -b:a 128k output.mp4` |

---
